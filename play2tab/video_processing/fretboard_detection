import cv2
import numpy as np
from skimage.transform import hough_line, hough_line_peaks
from itertools import combinations
from utils.utils import angle_diff

def nothing(x):
    pass


class ColorThresholder:
    def __init__(self):
        cv2.namedWindow('color thresholder')

        cv2.createTrackbar('HMin','color thresholder',0,179,nothing) # Hue is from 0-179 for Opencv
        cv2.createTrackbar('SMin','color thresholder',0,255,nothing)
        cv2.createTrackbar('VMin','color thresholder',0,255,nothing)
        cv2.createTrackbar('HMax','color thresholder',0,179,nothing)
        cv2.createTrackbar('SMax','color thresholder',0,255,nothing)
        cv2.createTrackbar('VMax','color thresholder',0,255,nothing)

        # Set default value for MAX HSV trackbars.
        cv2.setTrackbarPos('HMax', 'color thresholder', 179)
        cv2.setTrackbarPos('SMax', 'color thresholder', 255)
        cv2.setTrackbarPos('VMax', 'color thresholder', 255)

        self.hMin = self.sMin = self.vMin = self.hMax = self.sMax = self.vMax = 0
    
    def update(self, image):
        self.hMin = cv2.getTrackbarPos('HMin','color thresholder')
        self.sMin = cv2.getTrackbarPos('SMin','color thresholder')
        self.vMin = cv2.getTrackbarPos('VMin','color thresholder')

        self.hMax = cv2.getTrackbarPos('HMax','color thresholder')
        self.sMax = cv2.getTrackbarPos('SMax','color thresholder')
        self.vMax = cv2.getTrackbarPos('VMax','color thresholder')

        # Set minimum and max HSV values to display
        lower = np.array([self.hMin, self.sMin, self.vMin])
        upper = np.array([self.hMax, self.sMax, self.vMax])

        # Create HSV Image and threshold into a range.
        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        mask = cv2.inRange(hsv, lower, upper)
        output = cv2.bitwise_and(image, image, mask= mask)

        cv2.imshow('color thresholder', output)

# Initialize to check if HSV min/max value changes
hMin = sMin = vMin = hMax = sMax = vMax = 0
phMin = psMin = pvMin = phMax = psMax = pvMax = 0

def draw_line(rho, theta):
    a = np.cos(theta)
    b = np.sin(theta)
    x0 = a * rho
    y0 = b * rho
    pt1 = (int(x0 + 2000*(-b)), int(y0 + 2000*(a)))
    pt2 = (int(x0 - 2000*(-b)), int(y0 - 2000*(a)))
    cv2.line(cdst, pt1, pt2, (0,0,255), 1, cv2.LINE_AA)

if __name__ == '__main__':
    frame_number = 500
    cap = cv2.VideoCapture('test\\guitar.mp4')
    # cap.set(cv2.CAP_PROP_POS_FRAMES, frame_number-1)

    color_thresholder = ColorThresholder()

    while True:
        ret, frame = cap.read()
        if not ret:
            cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
            ret, frame = cap.read()

        color_thresholder.update(frame)

        # lower_threshold = 50
        # high_threshold = 150
        # aperture_size = 5
        # is_L2gradient = True
        # edges = cv2.Canny(frame, lower_threshold, high_threshold, aperture_size)

        # theta_tol = 5  # degree
        # rho_tol = 100  # pixel
        # tested_angles = np.linspace(-np.pi / 2, np.pi / 2, 360, endpoint=False)
        # h, theta, d = hough_line(edges, theta=tested_angles)
        # hspace, angles, dists = hough_line_peaks(h, theta, d, min_distance=9, min_angle=10, threshold=100)
        # parallel_lines = []
        # for [[hi, ri, ti], [hj, rj, tj]] in combinations(zip(hspace, dists, angles), 2):
        #     if angle_diff(ti, tj) < theta_tol / 180 * np.pi and abs(ri - rj) > rho_tol:
        #         parallel_lines.append([hi+hj, ri, ti, rj, tj])
        # parallel_lines = np.array(parallel_lines)


        # cdst = cv2.cvtColor(edges.copy(), cv2.COLOR_GRAY2BGR)
        # for line_pair in parallel_lines[parallel_lines[:, 0] >= 1*np.max(parallel_lines[:, 0]), :]:
        #     draw_line(line_pair[1], line_pair[2])
        #     draw_line(line_pair[3], line_pair[4])
        # cv2.imshow('', cdst)
        cv2.waitKey(1)